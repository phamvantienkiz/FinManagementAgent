app/config.py

Má»¥c Ä‘Ã­ch: Load env config, validate required vars.

Cáº§n implement:

from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    BOT_TOKEN: str
    WEBHOOK_SECRET_TOKEN: str | None = None
    USER_SERVICE_BASE: str
    AGENT_SERVICE_BASE: str | None = None
    REQUEST_TIMEOUT: int = 10
    LOG_LEVEL: str = "INFO"

settings = Settings()


Case cáº§n Ä‘áº¡t: lá»—i cáº¥u hÃ¬nh (missing env) pháº£i nÃ©m exception sá»›m khi app start. USER_SERVICE_BASE báº¯t buá»™c.

app/logger.py

Má»¥c Ä‘Ã­ch: Thiáº¿t láº­p logging chung (console JSON-friendly), dÃ¹ng á»Ÿ má»i file.

Cáº§n implement:

get_logger(name: str) â†’ tráº£ logging.Logger preconfigured (level tá»« config).

nÃªn log message cÃ³ correlation_id khi cÃ³ (tá»« utils).

Case cáº§n Ä‘áº¡t: logs dá»… Ä‘á»c khi debug webhook, log level cÃ³ thá»ƒ set via env.

app/telegram_client.py

Má»¥c Ä‘Ã­ch: Bao Ä‘Ã³ng Telegram API (all network calls) Ä‘á»ƒ dá»… test.

HÃ m cáº§n xÃ¢y:

async def send_message(chat_id: int, text: str, parse_mode: str | None = None) -> dict
async def send_typing(chat_id: int) -> dict  # optional UI hint
async def set_webhook(url: str, secret_token: str | None = None) -> dict
async def delete_webhook() -> dict


Behavior & errors:

DÃ¹ng httpx.AsyncClient() vá»›i timeout tá»« config.

Khi lá»—i httpx (timeout/5xx), raise custom TelegramClientError with detail; calling code sáº½ catch/log.

Retry: do not retry inside send_message â€” caller can choose to retry background.

Case cáº§n Ä‘áº¡t:

send_message thÃ nh cÃ´ng tráº£ JSON Telegram.

náº¿u rate-limited (429) hoáº·c 5xx â†’ log and raise.

app/user_client.py

Má»¥c Ä‘Ã­ch: TÆ°Æ¡ng tÃ¡c vá»›i User Service (service báº¡n Ä‘Ã£ cÃ³). Táº¥t cáº£ call tá»›i Supabase Ä‘Æ°á»£c thá»±c hiá»‡n thÃ´ng qua User Service API, khÃ´ng trá»±c tiáº¿p Supabase (tÃ¡ch concerns).

Endpoints assuming (from your user service):

GET {USER_SERVICE_BASE}/api/users/by-telegram/{telegram_id} â†’ 200 with user JSON or 404.

POST {USER_SERVICE_BASE}/api/users/register â†’ body: {telegram_id, phone, full_name, email} â†’ returns created user (or message + user).

POST {USER_SERVICE_BASE}/api/interactions â†’ body: {user_id, telegram_message_id, direction, message_text, metadata} â†’ logs interaction.

HÃ m cáº§n xÃ¢y:

async def get_user_by_telegram(telegram_id: int) -> dict | None
async def register_user_from_telegram(telegram_id: int, chat_obj: dict) -> dict
async def log_interaction(user_id: str, message_text: str, direction: str = "in", telegram_message_id: int | None = None, metadata: dict | None = None) -> dict
async def interaction_exists_by_telegram_message_id(telegram_message_id: int) -> bool


Behavior:

get_user_by_telegram:

call GET path; return dict on 200; return None on 404.

on other errors: raise UserServiceError.

register_user_from_telegram:

Build minimal payload: {"telegram_id": telegram_id, "phone": None, "full_name": "<first last>", "email": None}

POST to /api/users/register; handle both shapes: if returned { "message": "...", "user": {...} } or direct user object.

Return created user dict.

log_interaction:

Body should match your Supabase schema, e.g.

{
  "user_id": "uuid",
  "telegram_message_id": 12345,
  "direction": "in",
  "message_text": "Xin chao",
  "metadata": {"raw": {...}}
}


On 201/200 return created row dict. If user service down â†’ raise or return sentinel to storage_retry.

interaction_exists_by_telegram_message_id:

To dedupe: call user service interactions list with filter telegram_message_id=eq.<id> if your user service supports filtering; or call GET interactions and check.

Return boolean.

Case cáº§n Ä‘áº¡t:

New user flow: if GET returns None, register_user_from_telegram creates user and returns id.

Duplicate message detection: if interaction_exists_by_telegram_message_id True â†’ do not log nor reprocess.

Resilience: if user service unavailable, do not crash webhook; store log into retry queue.

app/agent_client.py

Má»¥c Ä‘Ã­ch: Gá»i agent service (AI) vÃ  chuáº©n hoÃ¡ tráº£ lá»i.

HÃ m cáº§n xÃ¢y:

async def ask_agent(user: dict, text: str) -> str


Behavior:

POST { "user": user, "text": text } to {AGENT_SERVICE_BASE}/api/respond.

Expect response JSON: {"reply":"..."}

Timeouts: use config.REQUEST_TIMEOUT or larger (agent maybe slower); if agent fails â†’ return fallback string such as "Agent táº¡m thá»i báº­n, vui lÃ²ng thá»­ láº¡i sau." and log.

Case cáº§n Ä‘áº¡t:

If AGENT_SERVICE_BASE not configured â†’ use simple fallback logic (echo + hint commands).

If agent returns structured suggestions (e.g. {"reply": "...", "actions":[...]}) you can parse and enrich message.

app/storage_retry.py (optional but recommended)

Má»¥c Ä‘Ã­ch: Táº¡m giá»¯ logs/interactions gá»­i tháº¥t báº¡i Ä‘á»ƒ retry (file-based or sqlite). Giáº£m máº¥t dá»¯ liá»‡u khi User Service down.

HÃ m cáº§n xÃ¢y:

def enqueue_failed_interaction(payload: dict) -> None
async def flush_retries() -> int  # attempt to resend queued items


Behavior:

Minimal: append JSON lines to .failed_interactions.log and flush.

flush_retries read file, try resend via user_client.log_interaction, remove items sent.

Called on startup and periodically (cron/thread) or exposed admin endpoint.

Case cáº§n Ä‘áº¡t:

When user service is down, webhook still returns 200 quickly; logs are queued. When service recovers, run flush_retries.

app/utils.py

Má»¥c Ä‘Ã­ch: Small helpers.

HÃ m cáº§n xÃ¢y:

def parse_update(update_json: dict) -> dict
# returns dict: {"chat_id": int, "telegram_id": int, "text": str, "message_id": int, "raw": update_json, "is_command": bool, "command": "/start" or None}

def build_display_name(chat: dict) -> str

def safe_extract_text(message: dict) -> str  # handle text, caption, callback_query etc.


Case cáº§n Ä‘áº¡t:

Support text messages, commands, caption of media, callback_query. For non-text (stickers/photos) record an indicator in metadata and store a textual description.

app/background_tasks.py

Má»¥c Ä‘Ã­ch: Business flow to run in BackgroundTasks so webhook responds fast.

HÃ m cáº§n xÃ¢y:

async def process_message_flow(user: dict, chat_id: int, message_text: str, message_id: int, raw: dict)


Flow inside:

call agent_client.ask_agent(user, message_text) â†’ reply_text.

call user_client.log_interaction(user_id, reply_text, direction="out", metadata={}).

call telegram_client.send_message(chat_id, reply_text).

Error handling:

If log_interaction fails â†’ enqueue to storage_retry.

If send_message fails â†’ log, retry a limited number of times (or enqueue).

Case cáº§n Ä‘áº¡t:

Agent slow: background ensures webhook returned 200 to Telegram immediately.

If agent returns structured responses (buttons/keyboard), support simple in-message options.

app/main.py

Má»¥c Ä‘Ã­ch: FastAPI app: webhook endpoint + health endpoints + startup/shutdown.

Routes to implement:

POST /webhook/telegram â€” main webhook.

GET /health â€” returns 200 OK.

optional POST /admin/flush-retries â€” call storage_retry.flush_retries() (protected by admin header or run locally).

Webhook behavior (detailed):

Validate X-Telegram-Bot-Api-Secret-Token header if WEBHOOK_SECRET_TOKEN set. If mismatch â†’ return 403.

Parse JSON. Extract message via utils.parse_update.

If no message or unsupported type â†’ return 200 (ignore).

Deduplicate: if message_id present and user_client.interaction_exists_by_telegram_message_id(message_id) returns True â†’ return 200 (no further processing).

user_client.get_user_by_telegram(telegram_id) â†’ if None call user_client.register_user_from_telegram(telegram_id, chat).

Call user_client.log_interaction(user_id, message_text, direction='in', telegram_message_id=message_id, metadata={"raw": raw}). If this fails, enqueue to retry.

Add background task background_tasks.add_task(process_message_flow, user, chat_id, message_text, message_id, raw).

Return {"ok": True} quickly (200).

Startup/Shutdown:

On startup call storage_retry.flush_retries() optionally.

create shared httpx AsyncClient single instance to reuse.

Security:

Consider requiring an internal API key when calling user service (X-API-Key) â€” set in .env and include in user_client headers.

Káº¿t quáº£ cuá»‘i cÃ¹ng cáº§n Ä‘áº¡t Ä‘Æ°á»£c lÃ  flow:
1. User tÃ¬m bot trÃªn Telegram vÃ  báº¯t Ä‘áº§u chat.

2. Messaging service nháº­n message â†’ gá»i User service Ä‘á»ƒ:

- Check náº¿u user chÆ°a cÃ³ thÃ¬ Ä‘Äƒng kÃ½ (auto-register).

- LÆ°u lá»‹ch sá»­ chat.

- Messaging service gá»i Agent service Ä‘á»ƒ xá»­ lÃ½ ná»™i dung tin nháº¯n.

3. Nháº­n káº¿t quáº£ tá»« Agent service vÃ  gá»­i láº¡i user trÃªn Telegram.

--------------------------------
DÆ°á»›i Ä‘Ã¢y lÃ  tá»•ng káº¿t cÃ¡c chá»‰nh sá»­a vá»«a thá»±c hiá»‡n Ä‘á»ƒ hoÃ n thiá»‡n messaging service theo Ä‘Ãºng flow MVP báº¡n yÃªu cáº§u, kÃ¨m Ä‘Ã¡nh giÃ¡ káº¿t ná»‘i vá»›i users service vÃ  cÃ¡c Ä‘á» xuáº¥t tiáº¿p theo.

âœ… Nhá»¯ng chá»‰nh sá»­a vá»«a hoÃ n thÃ nh
Thá»© tá»± xá»­ lÃ½ webhook Ä‘Æ°á»£c tá»‘i Æ°u:
Láº¥y/Ä‘Äƒng kÃ½ user trÆ°á»›c.
Sau Ä‘Ã³ má»›i dedupe interaction dá»±a trÃªn user_id + danh sÃ¡ch interactions gáº§n Ä‘Ã¢y.
Dedupe logic:
Thay vÃ¬ gá»i má»™t endpoint giáº£ Ä‘á»‹nh theo message_id, giá» hÃ m interaction_exists_by_telegram_message_id(user_id, telegram_message_id) láº¥y danh sÃ¡ch interactions gáº§n Ä‘Ã¢y qua get_interactions(user_id) vÃ  so khá»›p.
Metadata:
Bá» double wrap { "raw": {...} }. Giá» metadata truyá»n tháº³ng raw update vÃ o user service.
Outgoing interaction trong background_tasks.process_message_flow cÅ©ng Ä‘á»“ng bá»™ cÃ¡ch truyá»n metadata.
user_client.log_interaction khÃ´ng tá»± bá»c láº¡i metadata ná»¯a.
ThÃªm helper get_interactions trong user_client phá»¥c vá»¥ dedupe + cÃ³ thá»ƒ dÃ¹ng sau nÃ y cho context.
Kiá»ƒm tra toÃ n bá»™ file sá»­a Ä‘á»•i: khÃ´ng cÃ³ syntax error.
ğŸ” Flow hiá»‡n táº¡i (sau chá»‰nh sá»­a)
Telegram gá»­i update â†’ /webhook/telegram.
Parse update (chat_id, telegram_id, message_id, text).
Láº¥y user qua get_user_by_telegram:
Náº¿u khÃ´ng cÃ³: auto-register (dá»±a trÃªn first/last name).
Dedupe: náº¿u cÃ³ message_id vÃ  Ä‘Ã£ tá»“n táº¡i trong interactions gáº§n Ä‘Ã¢y â†’ tráº£ 200 ngay.
Log interaction direction=in (metadata = raw update).
BackgroundTask:
Gá»i agent (fallback náº¿u chÆ°a cÃ³ service).
Log outgoing interaction direction=out.
Gá»­i message tráº£ lá»i qua Telegram.
Tráº£ vá» {"ok": true} sá»›m Ä‘á»ƒ Telegram khÃ´ng timeout.
Náº¿u user service down trong quÃ¡ trÃ¬nh log: enqueue vÃ o .failed_interactions.log.
Startup: flush retry queue (gá»­i láº¡i cÃ¡c interaction tháº¥t báº¡i trÆ°á»›c Ä‘Ã³).
ğŸ” CÃ¡c phá»¥ thuá»™c cáº§n Ä‘áº£m báº£o á»Ÿ users service
Báº¡n nÃ³i users service Ä‘Ã£ á»•n Ä‘á»‹nh, váº­y xÃ¡c nháº­n thÃªm giÃºp:

Endpoint GET /api/users/by-telegram/{tid} tá»“n táº¡i (Ä‘Ã£ tháº¥y trong code trÆ°á»›c).
Endpoint POST /api/users/register vá»›i payload Ä‘Æ¡n giáº£n hoáº¡t Ä‘á»™ng.
Endpoint POST /api/interactions/ nháº­n Ä‘Ãºng cÃ¡c trÆ°á»ng:
user_id (UUID/string)
telegram_message_id (int | null)
direction (â€œinâ€ | â€œoutâ€)
message_text
metadata (JSON | null)
Endpoint GET /api/interactions/{user_id}?limit=... hoáº·c tráº£ vá» list interactions (hiá»‡n client Ä‘ang gá»i nhÆ° váº­y).
Náº¿u chÆ°a cÃ³ param limit, báº¡n cÃ³ thá»ƒ bá» qua vÃ¬ query string khÃ´ng áº£nh hÆ°á»Ÿng nhiá»u (server sáº½ ignore).
DB cÃ³ cá»™t telegram_message_id trong báº£ng interactions (nÃªn táº¡o INDEX + UNIQUE (user_id, telegram_message_id) náº¿u trÃ¡nh trÃ¹ng máº¡nh hÆ¡n).
Náº¿u chÆ°a cÃ³ endpoint /api/interactions/{user_id}, báº¡n cáº§n táº¡o Ä‘á»ƒ dedupe hoáº¡t Ä‘á»™ng tá»‘i Æ°u.

âš ï¸ CÃ¡c Ä‘iá»ƒm báº¡n nÃªn cÃ¢n nháº¯c (nhÆ°ng cÃ³ thá»ƒ Ä‘á»ƒ sau vÃ¬ lÃ  MVP)
Háº¡ng má»¥c	Má»©c Ä‘á»™ Æ°u tiÃªn	Ghi chÃº
UNIQUE (user_id, telegram_message_id)	Cao	Cháº·n trÃ¹ng á»Ÿ má»©c DB náº¿u webhook gá»­i láº¡i.
Giáº£m kÃ­ch thÆ°á»›c metadata	Trung bÃ¬nh	Raw Telegram update cÃ³ thá»ƒ lá»›n; cÃ³ thá»ƒ lá»c.
CÆ¡ cháº¿ flush Ä‘á»‹nh ká»³ retry	Trung bÃ¬nh	Hiá»‡n chá»‰ cháº¡y startup + admin endpoint.
Logging 429 tá»« Telegram	Tháº¥p	ThÃªm branch riÃªng Ä‘á»ƒ log retry_after.
Ná»™i bá»™ hÃ³a HEADERS (X-Internal-Key)	Tháº¥p (MVP)	Sau nÃ y thÃªm báº£o máº­t giá»¯a services.
Adaptive agent timeout	Trung bÃ¬nh	Agent cÃ³ thá»ƒ cáº§n timeout lá»›n hÆ¡n user service.
âœ… Tráº¡ng thÃ¡i hiá»‡n táº¡i so vá»›i yÃªu cáº§u MVP
Flow 1â†’2â†’3 trong tÃ i liá»‡u: ÄÃƒ ÄÃP á»¨NG vá» máº·t logic vÃ  code khung trong messaging.
Báº¡n cÃ³ thá»ƒ táº­p trung phÃ¡t triá»ƒn Agent service ngay bÃ¢y giá»; chá»‰ cáº§n:

Triá»ƒn khai endpoint POST /api/respond á»Ÿ agent service tráº£ JSON: {"reply": "â€¦"}.
Set env AGENT_SERVICE_BASE trong messaging.
â–¶ï¸ CÃ¡ch cháº¡y thá»­ nhanh (gá»£i Ã½)
Cháº¡y users service (port 8000).
Cháº¡y messaging service (vÃ­ dá»¥ port 8001):
Giáº£ láº­p webhook:
Kiá»ƒm tra:
User má»›i Ä‘Æ°á»£c táº¡o bÃªn users.
1 interaction in + 1 interaction out.
Gá»­i láº¡i cÃ¹ng message_id â†’ khÃ´ng táº¡o interaction má»›i.
ğŸš€ Gá»£i Ã½ nhá» Ä‘á»ƒ káº¿t ná»‘i Agent sau nÃ y
Trong agent_client.ask_agent báº¡n cÃ³ thá»ƒ má»Ÿ rá»™ng:

Náº¿u reply tráº£ vá» kÃ¨m actions/buttons â†’ lÆ°u vÃ o metadata outgoing interaction.
ThÃªm optional memory context: gá»­i 3â€“5 interaction cuá»‘i (láº¥y tá»« get_interactions) vÃ o payload agent.