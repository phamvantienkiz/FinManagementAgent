app/config.py

Mục đích: Load env config, validate required vars.

Cần implement:

from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    BOT_TOKEN: str
    WEBHOOK_SECRET_TOKEN: str | None = None
    USER_SERVICE_BASE: str
    AGENT_SERVICE_BASE: str | None = None
    REQUEST_TIMEOUT: int = 10
    LOG_LEVEL: str = "INFO"

settings = Settings()


Case cần đạt: lỗi cấu hình (missing env) phải ném exception sớm khi app start. USER_SERVICE_BASE bắt buộc.

app/logger.py

Mục đích: Thiết lập logging chung (console JSON-friendly), dùng ở mọi file.

Cần implement:

get_logger(name: str) → trả logging.Logger preconfigured (level từ config).

nên log message có correlation_id khi có (từ utils).

Case cần đạt: logs dễ đọc khi debug webhook, log level có thể set via env.

app/telegram_client.py

Mục đích: Bao đóng Telegram API (all network calls) để dễ test.

Hàm cần xây:

async def send_message(chat_id: int, text: str, parse_mode: str | None = None) -> dict
async def send_typing(chat_id: int) -> dict  # optional UI hint
async def set_webhook(url: str, secret_token: str | None = None) -> dict
async def delete_webhook() -> dict


Behavior & errors:

Dùng httpx.AsyncClient() với timeout từ config.

Khi lỗi httpx (timeout/5xx), raise custom TelegramClientError with detail; calling code sẽ catch/log.

Retry: do not retry inside send_message — caller can choose to retry background.

Case cần đạt:

send_message thành công trả JSON Telegram.

nếu rate-limited (429) hoặc 5xx → log and raise.

app/user_client.py

Mục đích: Tương tác với User Service (service bạn đã có). Tất cả call tới Supabase được thực hiện thông qua User Service API, không trực tiếp Supabase (tách concerns).

Endpoints assuming (from your user service):

GET {USER_SERVICE_BASE}/api/users/by-telegram/{telegram_id} → 200 with user JSON or 404.

POST {USER_SERVICE_BASE}/api/users/register → body: {telegram_id, phone, full_name, email} → returns created user (or message + user).

POST {USER_SERVICE_BASE}/api/interactions → body: {user_id, telegram_message_id, direction, message_text, metadata} → logs interaction.

Hàm cần xây:

async def get_user_by_telegram(telegram_id: int) -> dict | None
async def register_user_from_telegram(telegram_id: int, chat_obj: dict) -> dict
async def log_interaction(user_id: str, message_text: str, direction: str = "in", telegram_message_id: int | None = None, metadata: dict | None = None) -> dict
async def interaction_exists_by_telegram_message_id(telegram_message_id: int) -> bool


Behavior:

get_user_by_telegram:

call GET path; return dict on 200; return None on 404.

on other errors: raise UserServiceError.

register_user_from_telegram:

Build minimal payload: {"telegram_id": telegram_id, "phone": None, "full_name": "<first last>", "email": None}

POST to /api/users/register; handle both shapes: if returned { "message": "...", "user": {...} } or direct user object.

Return created user dict.

log_interaction:

Body should match your Supabase schema, e.g.

{
  "user_id": "uuid",
  "telegram_message_id": 12345,
  "direction": "in",
  "message_text": "Xin chao",
  "metadata": {"raw": {...}}
}


On 201/200 return created row dict. If user service down → raise or return sentinel to storage_retry.

interaction_exists_by_telegram_message_id:

To dedupe: call user service interactions list with filter telegram_message_id=eq.<id> if your user service supports filtering; or call GET interactions and check.

Return boolean.

Case cần đạt:

New user flow: if GET returns None, register_user_from_telegram creates user and returns id.

Duplicate message detection: if interaction_exists_by_telegram_message_id True → do not log nor reprocess.

Resilience: if user service unavailable, do not crash webhook; store log into retry queue.

app/agent_client.py

Mục đích: Gọi agent service (AI) và chuẩn hoá trả lời.

Hàm cần xây:

async def ask_agent(user: dict, text: str) -> str


Behavior:

POST { "user": user, "text": text } to {AGENT_SERVICE_BASE}/api/respond.

Expect response JSON: {"reply":"..."}

Timeouts: use config.REQUEST_TIMEOUT or larger (agent maybe slower); if agent fails → return fallback string such as "Agent tạm thời bận, vui lòng thử lại sau." and log.

Case cần đạt:

If AGENT_SERVICE_BASE not configured → use simple fallback logic (echo + hint commands).

If agent returns structured suggestions (e.g. {"reply": "...", "actions":[...]}) you can parse and enrich message.

app/storage_retry.py (optional but recommended)

Mục đích: Tạm giữ logs/interactions gửi thất bại để retry (file-based or sqlite). Giảm mất dữ liệu khi User Service down.

Hàm cần xây:

def enqueue_failed_interaction(payload: dict) -> None
async def flush_retries() -> int  # attempt to resend queued items


Behavior:

Minimal: append JSON lines to .failed_interactions.log and flush.

flush_retries read file, try resend via user_client.log_interaction, remove items sent.

Called on startup and periodically (cron/thread) or exposed admin endpoint.

Case cần đạt:

When user service is down, webhook still returns 200 quickly; logs are queued. When service recovers, run flush_retries.

app/utils.py

Mục đích: Small helpers.

Hàm cần xây:

def parse_update(update_json: dict) -> dict
# returns dict: {"chat_id": int, "telegram_id": int, "text": str, "message_id": int, "raw": update_json, "is_command": bool, "command": "/start" or None}

def build_display_name(chat: dict) -> str

def safe_extract_text(message: dict) -> str  # handle text, caption, callback_query etc.


Case cần đạt:

Support text messages, commands, caption of media, callback_query. For non-text (stickers/photos) record an indicator in metadata and store a textual description.

app/background_tasks.py

Mục đích: Business flow to run in BackgroundTasks so webhook responds fast.

Hàm cần xây:

async def process_message_flow(user: dict, chat_id: int, message_text: str, message_id: int, raw: dict)


Flow inside:

call agent_client.ask_agent(user, message_text) → reply_text.

call user_client.log_interaction(user_id, reply_text, direction="out", metadata={}).

call telegram_client.send_message(chat_id, reply_text).

Error handling:

If log_interaction fails → enqueue to storage_retry.

If send_message fails → log, retry a limited number of times (or enqueue).

Case cần đạt:

Agent slow: background ensures webhook returned 200 to Telegram immediately.

If agent returns structured responses (buttons/keyboard), support simple in-message options.

app/main.py

Mục đích: FastAPI app: webhook endpoint + health endpoints + startup/shutdown.

Routes to implement:

POST /webhook/telegram — main webhook.

GET /health — returns 200 OK.

optional POST /admin/flush-retries — call storage_retry.flush_retries() (protected by admin header or run locally).

Webhook behavior (detailed):

Validate X-Telegram-Bot-Api-Secret-Token header if WEBHOOK_SECRET_TOKEN set. If mismatch → return 403.

Parse JSON. Extract message via utils.parse_update.

If no message or unsupported type → return 200 (ignore).

Deduplicate: if message_id present and user_client.interaction_exists_by_telegram_message_id(message_id) returns True → return 200 (no further processing).

user_client.get_user_by_telegram(telegram_id) → if None call user_client.register_user_from_telegram(telegram_id, chat).

Call user_client.log_interaction(user_id, message_text, direction='in', telegram_message_id=message_id, metadata={"raw": raw}). If this fails, enqueue to retry.

Add background task background_tasks.add_task(process_message_flow, user, chat_id, message_text, message_id, raw).

Return {"ok": True} quickly (200).

Startup/Shutdown:

On startup call storage_retry.flush_retries() optionally.

create shared httpx AsyncClient single instance to reuse.

Security:

Consider requiring an internal API key when calling user service (X-API-Key) — set in .env and include in user_client headers.

Kết quả cuối cùng cần đạt được là flow:
1. User tìm bot trên Telegram và bắt đầu chat.

2. Messaging service nhận message → gọi User service để:

- Check nếu user chưa có thì đăng ký (auto-register).

- Lưu lịch sử chat.

- Messaging service gọi Agent service để xử lý nội dung tin nhắn.

3. Nhận kết quả từ Agent service và gửi lại user trên Telegram.

--------------------------------
Dưới đây là tổng kết các chỉnh sửa vừa thực hiện để hoàn thiện messaging service theo đúng flow MVP bạn yêu cầu, kèm đánh giá kết nối với users service và các đề xuất tiếp theo.

✅ Những chỉnh sửa vừa hoàn thành
Thứ tự xử lý webhook được tối ưu:
Lấy/đăng ký user trước.
Sau đó mới dedupe interaction dựa trên user_id + danh sách interactions gần đây.
Dedupe logic:
Thay vì gọi một endpoint giả định theo message_id, giờ hàm interaction_exists_by_telegram_message_id(user_id, telegram_message_id) lấy danh sách interactions gần đây qua get_interactions(user_id) và so khớp.
Metadata:
Bỏ double wrap { "raw": {...} }. Giờ metadata truyền thẳng raw update vào user service.
Outgoing interaction trong background_tasks.process_message_flow cũng đồng bộ cách truyền metadata.
user_client.log_interaction không tự bọc lại metadata nữa.
Thêm helper get_interactions trong user_client phục vụ dedupe + có thể dùng sau này cho context.
Kiểm tra toàn bộ file sửa đổi: không có syntax error.
🔁 Flow hiện tại (sau chỉnh sửa)
Telegram gửi update → /webhook/telegram.
Parse update (chat_id, telegram_id, message_id, text).
Lấy user qua get_user_by_telegram:
Nếu không có: auto-register (dựa trên first/last name).
Dedupe: nếu có message_id và đã tồn tại trong interactions gần đây → trả 200 ngay.
Log interaction direction=in (metadata = raw update).
BackgroundTask:
Gọi agent (fallback nếu chưa có service).
Log outgoing interaction direction=out.
Gửi message trả lời qua Telegram.
Trả về {"ok": true} sớm để Telegram không timeout.
Nếu user service down trong quá trình log: enqueue vào .failed_interactions.log.
Startup: flush retry queue (gửi lại các interaction thất bại trước đó).
🔍 Các phụ thuộc cần đảm bảo ở users service
Bạn nói users service đã ổn định, vậy xác nhận thêm giúp:

Endpoint GET /api/users/by-telegram/{tid} tồn tại (đã thấy trong code trước).
Endpoint POST /api/users/register với payload đơn giản hoạt động.
Endpoint POST /api/interactions/ nhận đúng các trường:
user_id (UUID/string)
telegram_message_id (int | null)
direction (“in” | “out”)
message_text
metadata (JSON | null)
Endpoint GET /api/interactions/{user_id}?limit=... hoặc trả về list interactions (hiện client đang gọi như vậy).
Nếu chưa có param limit, bạn có thể bỏ qua vì query string không ảnh hưởng nhiều (server sẽ ignore).
DB có cột telegram_message_id trong bảng interactions (nên tạo INDEX + UNIQUE (user_id, telegram_message_id) nếu tránh trùng mạnh hơn).
Nếu chưa có endpoint /api/interactions/{user_id}, bạn cần tạo để dedupe hoạt động tối ưu.

⚠️ Các điểm bạn nên cân nhắc (nhưng có thể để sau vì là MVP)
Hạng mục	Mức độ ưu tiên	Ghi chú
UNIQUE (user_id, telegram_message_id)	Cao	Chặn trùng ở mức DB nếu webhook gửi lại.
Giảm kích thước metadata	Trung bình	Raw Telegram update có thể lớn; có thể lọc.
Cơ chế flush định kỳ retry	Trung bình	Hiện chỉ chạy startup + admin endpoint.
Logging 429 từ Telegram	Thấp	Thêm branch riêng để log retry_after.
Nội bộ hóa HEADERS (X-Internal-Key)	Thấp (MVP)	Sau này thêm bảo mật giữa services.
Adaptive agent timeout	Trung bình	Agent có thể cần timeout lớn hơn user service.
✅ Trạng thái hiện tại so với yêu cầu MVP
Flow 1→2→3 trong tài liệu: ĐÃ ĐÁP ỨNG về mặt logic và code khung trong messaging.
Bạn có thể tập trung phát triển Agent service ngay bây giờ; chỉ cần:

Triển khai endpoint POST /api/respond ở agent service trả JSON: {"reply": "…"}.
Set env AGENT_SERVICE_BASE trong messaging.
▶️ Cách chạy thử nhanh (gợi ý)
Chạy users service (port 8000).
Chạy messaging service (ví dụ port 8001):
Giả lập webhook:
Kiểm tra:
User mới được tạo bên users.
1 interaction in + 1 interaction out.
Gửi lại cùng message_id → không tạo interaction mới.
🚀 Gợi ý nhỏ để kết nối Agent sau này
Trong agent_client.ask_agent bạn có thể mở rộng:

Nếu reply trả về kèm actions/buttons → lưu vào metadata outgoing interaction.
Thêm optional memory context: gửi 3–5 interaction cuối (lấy từ get_interactions) vào payload agent.